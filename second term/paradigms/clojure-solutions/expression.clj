;HW 10
(defn makeOp [f args] (fn[m] (apply f (map #(% m) args)))) (defn add [& args] (makeOp + args)) (defn subtract [& args] (makeOp - args)) (defn multiply [& args] (makeOp * args)) (defn divide [& args] (makeOp (fn [x y] (/ (double x) (double y))) args)) (defn negate [& args] (makeOp - args)) (defn exp [& args] (makeOp (fn [x] (Math/exp x)) args)) (defn ln [& args] (makeOp (fn [x] (Math/log x)) args))(defn constant [cnst] (constantly cnst))(defn variable [v] (fn [f] (f v)))(def operations {'+ add, '- subtract, '* multiply, '/ divide, 'negate negate, 'exp exp, 'ln ln}) (defn parseFunction [expression] (letfn [(parse [expr] (cond (symbol? expr) (variable (str expr)) (number? expr) (constant expr) :else (apply (operations (first expr)) (map parse (rest expr)))))] (parse (read-string expression))))
;HW 11
(declare ZERO, ONE)(defn evaluate [expr, x] ((.evaluate expr) x)) (defn toString [expr] (.string expr)) (defn diff [expr, x] ((.dff expr) x)) (definterface Expression (evaluate []) (string []) (dff [])) (deftype Const [cnst] Expression (evaluate [this] (fn [m] cnst)) (string [this] (format "%.1f" (double cnst))) (dff [this] (fn [m] ZERO))) (defn Constant [cnst] (Const. cnst)) (def ZERO (Constant 0)) (def ONE (Constant 1)) (deftype Var [v] Expression (evaluate [this] (fn [m] (m (str v)))) (string [this] (str v)) (dff [this] (fn [m] (if (= m v) ONE ZERO)))) (defn Variable [v] (Var. v)) (deftype UnaryOperation [x, op, f, diffMethod] Expression (evaluate [this] (fn [m] (f (evaluate x m)))) (string [this] (str "(" op " " (.string x) ")")) (dff [this] (fn [m] (diffMethod x (diff x m))))) (deftype BinaryOperation [x, y, op, f, diffMethod] Expression (evaluate [this] (fn [m] (f (evaluate x m) (evaluate y m)))) (string [this] (str "(" op " " (.string x) " " (.string y) ")")) (dff [this] (fn [m] (diffMethod x y (diff x m) (diff y m))))) (defn Add [x, y] (BinaryOperation., x, y, "+", +, (fn [x, y, dx, dy] (Add dx dy)))) (defn Subtract [x, y] (BinaryOperation. x, y, "-", -, (fn [x, y, dx, dy] (Subtract dx dy)))) (defn Multiply [x, y] (BinaryOperation. x, y, "*", *, (fn [x, y, dx, dy] (Add (Multiply x dy) (Multiply dx y))))) (defn Divide [x, y] (BinaryOperation. x, y, "/", (fn [x, y] (/ (double x) (double y))), (fn [x, y, dx, dy] (Divide (Subtract (Multiply dx y) (Multiply x dy)) (Multiply y y))))) (defn Negate [x] (UnaryOperation. x, "negate", -, (fn [x, dx] (Negate dx)))) (defn Exp [x] (UnaryOperation. x, "exp", (fn [x] (Math/exp x)), (fn [x, dx] (Multiply (Exp x) dx)))) (defn Ln [x] (UnaryOperation. x, "ln", (fn [x] (Math/log x)), (fn [x, dx] (Divide dx x)))) (def operations2 {'+ Add, '- Subtract, '* Multiply, '/ Divide, 'negate Negate, 'exp Exp, 'ln Ln}) (defn parseObject [expression] (letfn [(parse [expr] (cond (symbol? expr) (Variable (str expr)) (number? expr) (Constant expr) :else (apply (operations2 (first expr)) (map parse (rest expr)))))] (parse (read-string expression))))